# Writing a C Compiler - Chapter 2 - in Zig

Done Date: 2025-05-14

[Two chapters](c2.md) of [Writing a C Compiler](https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html) done, many more to go, and it is time to implement binary expressions. But before I get into that, let me rant a bit about Zig.

## The War Against Tabs

Zig's grammar does not tolerate tha tab character anywhere in the file. This is unfortunate, as I like tabs. With source code, it is whatever, as `zig fmt` takes care of it, but can I please type my tabs in multiline string literals please?

I like to indent the output, whether it is the parser's debugging output or the final assembly output, with tabs. It just makes sense. It is simpler conceptually to type one tab twice for the second level of indentation than to type a space 4 or 8 or 16 times. Put a tab, and let the user choose the preferred tab width.

But Zig's grammar will have none of it. There can be no tab characters in the fle (albeit it is tolerated a bit at indentation before `zig fmt` gets rid of it all.) This puts me in a dilemma. Consider this piece of code for emitting the `ret` instruction.

```zig
.ret => try writer.writeAll(
    "\tmovq    %rbp, %rsp\n" ++
    "\tpopq    %rbp\n" ++
    "\tret"
),
```

Reasonable, right? But `zig fmt` takes a machete to it, and they no longer nicely align.

```zig
.ret => try writer.writeAll(
    "\tmovq    %rbp, %rsp\n" ++
        "\tpopq    %rbp\n" ++
        "\tret",
),
```

The next reasonable solution is Zig's rather clever and very nice multiline string literals. It is literally my favorite piece of syntax in Zig. So much more ergonomic and grokkable and understandable than Swift's `"""` or Rust's .. nothing. So naturally, I'd type it like this:

```zig
.ret => try writer.writeAll(
    \\	movq    %rbp, %rsp
    \\	popq    %rbp
    \\	ret
),
//    ^^ tab character here.
```

But this does not compile. Just does not. No tab characters allowed. One could argue that this decision reduces confusion over a variable width character like tab and hides the true intentions of whatever. **I do not care**. I want my tabs, goddammit. I would be ok with escaping tabs `'\t'`, but escapes do not work in multiline string literals. I could use `std.fmt.comptimePrint`, but that adds too much obfucation and makes using the literals as the `fmt` arguments in `print` statements a lot more complicated. It is just annoying all around.

Anyway, with some magic of `comptime`, and trial and error of Zig's comptime rules, I came up with this ~~macro~~ function:

```zig
inline fn indent(
    comptime text: []const u8,
) []const u8 {
    comptime {
        var iter = std.mem.splitScalar(u8, text, '\n');
        var res: []const u8 = "";

        while (iter.next()) |line|
            res = if (line.len > 0 and line[0] != '_')
                res ++ "\t" ++ line ++ "\n"
            else
                res ++ line ++ "\n";

        return res[0 .. res.len - 1];
    }
}
```

`inline fn` and the `comptime` block conspire together to make sure the body of this function always ever runs at `comptime` and never at run time, with no ceremony at the calling site.

The code itself is fairly straightfoard: it separates the input by lines; adds a new line to all lines; and indents (with tabs!) any line that is not empty and does not start with `_`, for label and function names. This is specific to my use case, but it is fine. It is used like this.

```zig
.ret => try writer.writeAll(indent(
    \\movq    %rbp, %rsp
    \\popq    %rbp
    \\ret
)),
```

Almost invisible, What's better is that, since it returns a `comptime` known string, it can be used as the `fmt` argument in print functions, like the following snippit for the function's prelude (which also showcases the `_` and the empty line rules).

```zig
try writer.print(indent(
    \\.globl _{0s}
    \\_{0s}:
    \\pushq   %rbp
    \\movq    %rsp, %rbp
    \\
), .{self.name});
```

This prints, for name `"main"`, as intended, as follows:

```asm
	.globl _main
_main:
	pushq   %rbp
	movq    %rsp, %rbp
```

So much pain would have been avoided if I could just type the damn byte. Now, back to business.

---

## Lexer

Updating the lexer requires adding four new tokens, `+`, `*`, `/`, and `%`. Where is subtrqction, you say? We already lex it, dummy. A failure mode for `++`, like done in Chapter 2, is not necessary, because `1 ++ 2` would be rejected by the parser later anyway. And there is no disambiguity about prefix operators, as the `+` unary prefix operator is not implemented either. This makes things so considerably simple that I will not bother writing the update down. On to parsing, which is way more interesting.
