# Writing a C Compiler - Chapter 4 - in Zig

<!-- Done Date: 2025-05-17 -->

[Three chapters](c3.md) out of who knows from [Writing a C Compiler](https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html). Time onto Chapter 4. Chapter 4 is about, let me check, "logical and relational operators". Great. More operators.

---

## Lexer

You would expect the lexer by now to be a boring done deal, and you would be right. However, this is _slightly_ more interesting because I get to add more states to the state machine!

The tokens for today are the following: `!`, `&&`, `||`, `==`, `!=`, `<`, `>`, `<=`, and `>=`. As I am not supporting bitshift operations, I will consider those tokens (specifically `&` and `|`) a failure state. The tests will not have them, either way.

Adding the token tags is straightforward. The `State` enum however, should have a new state for every partual application. This is the new `State`:

```zig
const State = enum {
    start,
    identifier,
    int,
    hyphen,

    // new
    bang,
    ambersand,
    pipe,
    equals,
    lesser_than,
    greater_than,
};
```

The character in which the tokenizer enters these states is, I think, self expalantory. This, for example, is `pipe`, and `lesser_than`.

```zig
.start => switch (self.buffer[self.index]) {
    // snip --
    '|' => continue :state .pipe,
    '<' => continue :state .lesser_than,
    // snip --
],
.pipe => {
    self.index += 1;
    switch (self.buffer[self.index]) {
        '|' => {
            self.index += 1;
            result.tag = .double_pipe;
        },
        else => result.tag = .invalid,
    }
},
.lesser_than => {
    self.index += 1;
    switch (self.buffer[self.index]) {
        '=' => {
            self.index += 1;
            result.tag = .lesser_equals;
        },
        else => result.tag = .lesser_then,
    }
},
```

## Parser
