# Writing a C Compiler - Chapter 4 - in Zig

<!-- Done Date: 2025-05-17 -->

[Three chapters](c3.md) out of who knows from [Writing a C Compiler](https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html). Time onto Chapter 4. Chapter 4 is about, let me check, "logical and relational operators". Great. More operators.

---

## Lexer

You would expect the lexer by now to be a boring done deal, and you would be right. However, this is _slightly_ more interesting because I get to add more states to the state machine!

The tokens for today are the following: `!`, `&&`, `||`, `==`, `!=`, `<`, `>`, `<=`, and `>=`. As I am not supporting bitshift operations, I will consider those tokens (specifically `&` and `|`) a failure state. The tests will not have them, either way.

Adding the token tags is straightforward. The `State` enum however, should have a new state for every partual application. This is the new `State`:

```zig
const State = enum {
    start,
    identifier,
    int,
    hyphen,

    // new
    bang,
    ambersand,
    pipe,
    equals,
    lesser_than,
    greater_than,
};
```

The character in which the tokenizer enters these states is, I think, self expalantory. This, for example, is `pipe`, and `lesser_than`.

```zig
.start => switch (self.buffer[self.index]) {
    // snip --
    '|' => continue :state .pipe,
    '<' => continue :state .lesser_than,
    // snip --
],
.pipe => {
    self.index += 1;
    switch (self.buffer[self.index]) {
        '|' => {
            self.index += 1;
            result.tag = .double_pipe;
        },
        else => result.tag = .invalid,
    }
},
.lesser_than => {
    self.index += 1;
    switch (self.buffer[self.index]) {
        '=' => {
            self.index += 1;
            result.tag = .lesser_equals;
        },
        else => result.tag = .lesser_then,
    }
},
```

## Parser

The parse is a relatively simpler affair. More binary operations with different precedence levels. None of them are right associative, so nothing but updating the AST and the various `switch` statements. Nothing much to write about.

## Unit Tests

To spice up this section, I have decided to take on writing unit tests for the parser. Zig has first class support for unit tests. Make a block titled `test` and the compiler sees it. The only problem is hooking it in the build system.

Back in chapter 2, I think, I rejigged the `zig build test` command to run the Book's test suite. As in, it just compiles and installs the binary as normal, then runs a shell command. Zig's built in testing support requires a different kind of wiring.

Thankfully, the default output with `zig init` contains all the necessary pieces, I can reuse those. One question remains is whether to tie them to the suit's test suite, so both run with `zig build test`, or have it a separate command. I believe having it a separate command is best, to cut down on the, already slow, testing time.

I shall change the existing `test` command to `submit` (so I'd type `zig build submit`), and have the `test` command for unit tests. For reference, this is pur old step after changing the name. (The block is organizational).

```zig
{ // `zig build submit` command
    const test_step = b.step("submit", "Run the Book's test suite");

    // subshells. how do they work.
    const inner_command = try std.mem.join(b.allocator, " ", &.{
        "../writing-a-c-compiler-tests/test_compiler",
        b.pathJoin(&.{ b.exe_dir, "paella" }),
        try std.mem.join(
            b.allocator,
            " ",
            b.args orelse &.{""},
        ),
    });

    // does this work like i think it does?
    const test_command = b.addSystemCommand(
        &.{ "arch", "-x86_64", "zsh", "-c", inner_command },
    );

    test_command.step.dependOn(b.getInstallStep());
    test_step.dependOn(&test_command.step);
}
```

Copying from the default `build.zig` and trimming unnecessary things, I get this:

```zig
{ // `zig build test` command
    const test_step = b.step("test", "Run unit tests");

    const exe_unit_tests = b.addTest(.{
        .root_module = exe_mod,
    });
    const run_exe_unit_tests = b.addRunArtifact(exe_unit_tests);

    test_step.dependOn(&run_exe_unit_tests.step);
}
```

And .. that should be it? To test whether the test command run, I shall write a `test` to test whether 2 + 2 equals 4 in `main.zig`.

```zig
test "test the test" {
    try std.testing.expect(2 + 2 == 4);
}
```

Ok `zig build test` comes and goes and says nothing. Let's see if it can detect a failure. I shall expectt 2 + 2 does not equal 4.

```zig
test "test the test" {
    try std.testing.expect(2 + 2 != 4);
}
```

And it fails. So our tests work! Putting it `parser.zig` however, does not seem to work. Tests pass no matter what I expect. What gives?

After asking around in the Zig discord, this is a known thing.  Zig's compiler is lazy, and does not look at functions not referenced from `main.zig`. But because the test executable does *not* run `fn main`, it does *not* see any modules that referenced within `main.zig` but not referenced in `main.zig`'s *tests*.

It is dumb as fuck, if you ask me. And honestly I cannot tell if this is a deliberate dsign decision or just a known bug. The solution is, well, to write a `test` block in `main.zig` that references the files in which I'd like to run tests.[^language] The most straightforward way to do this is this:

[^language]: Yet another point for debugging your language knowledge. And do not tell me this is not actually part of the language.

```zig
test {
  std.testing.refAllDeclsRecursive(@This());
}
```

And now the tests in `parse.zig` pass and fail as expected. This is apparently a hack and not recommended. The recommended way is even more stupid looking, which only imports `parser.zig`, and I'd have to do it for every file and every sub import.

```zig
test {
    _ = parser;
}
```

Having gone that far, let's actually write our unit test in `parse.zig`.

```zig
test "precedence 1" {
    const t = std.testing;
    const src = "3 * 4 + 5;";
    var tokens = lexer.Tokenizer.init(src);

    var a_a = std.heap.ArenaAllocator.init(t.allocator);
    defer a_a.deinit();
    const a = a_a.allocator();

    const result = try parse_expr(a, &tokens, 0);

    try t.expect(result.* == .binop_add);
    try t.expectFmt("(+ (* 3 4) 5)", "{}", .{result});
}
```

My first drafts of the test failed because I was leaking memory, hence the adding an arena ceremony. It is a bit more ceremony than I expected, but it is fine. WHo needs unit testing anyway? End to end testing is where it is at.

---

## Internal Representation
