# Writing a C Compiler - Chapter 8 - in Zig

<!-- Done Date: 2025-05-25 -->

[Seven](c7.md) done of [Writing a C Compiler](https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html), a few more to go. Now is the time for loops.

---

## Lexer, AST and Parser

The lexer is just a few new keywords. Been there, done that. Changes to the AST are more interesting. No less than five new statements, one for every new keyword. Here is the new `Stmt` without further ado:

```zig
pub const Stmt = union(enum) {
    @"return": *Expr,
    expr: *Expr,
    @"if": struct { cond: *Expr, then: *Stmt, @"else": ?*Stmt },
    compound: Block,
    @"break": ?[:0]const u8,
    @"continue": ?[:0]const u8,
    @"while": While,
    do_while: While,
    @"for": For,
    null: void,

    const While = struct {
        cond: *Expr,
        body: *Stmt,
        label: ?[:0]const u8,
    };

    pub const For = struct {
        label: ?[:0]const u8,
        init: Init,
        cond: ?*Expr,
        post: ?*Expr,
        body: *Stmt,

        pub const Init = union(enum) { decl: *Decl, expr: *Expr, none },
    };
}
```

A few notes. Each of there statements have an optional label argument. This label is used later to associate `break`s and `continue`s with their associated loops during semantic analysis. You cannot actually assign labels to loops in C as far as I know.

Also, usually for a one off subtype like `For` here, I put it inline. But this one is big and hairy and has a subtype of its own that it warrants the spcial treatment. `Init` itself is named because I am naming it later in the parser. To map the fields to the actualy `for` loop in code, it is basically this:

```c
for (init, cond, post) body
```

All the three first fields are optional. The reason that `none` is a state of `init` instead of using an optional is shave a few bytes from the size of `init` (and therefore the whole `For` type and then the whole `Stmt` type).

Parsing these are a bit more interesting. First, the straightforward `break` and `continue`.

```zig
.keyword_break => {
    try expect(.semicolon, tokens);
    return .{ .@"break" = null };
},
.keyword_continue => {
    try expect(.semicolon, tokens);
    return .{ .@"continue" = null };
},
```

`while` and `do while` are slightly more interesting. They're similar to `if`.

```zig
.keyword_while => {
    try expect(.l_paren, tokens);
    const cond = try parse_expr(arena, tokens, 0);
    const cond_ptr = try utils.create(arena, cond);
    try expect(.r_paren, tokens);

    const body = try parse_stmt(arena, tokens);
    const body_ptr = try utils.create(arena, body);

    return .{ .@"while" = .{
        .cond = cond_ptr,
        .body = body_ptr,
        .label = null,
    } };
},
.keyword_do => {
    const body = try parse_stmt(arena, tokens);
    const body_ptr = try utils.create(arena, body);

    try expect(.keyword_while, tokens);
    try expect(.l_paren, tokens);
    const cond = try parse_expr(arena, tokens, 0);
    const cond_ptr = try utils.create(arena, cond);
    try expect(.r_paren, tokens);
    try expect(.semicolon, tokens);

    return .{ .do_while = .{
        .cond = cond_ptr,
        .body = body_ptr,
        .label = null,
    } };
},
```

Now time for the final boss. `for`. There is a funny complication here that I hit on my previous Rust implementation. The parsing code for variable declarations already expects a semicolon, but the one for expressions _does not_. So if I determine the `init` statement is a variable declaration, I need not check for a semicolon, whereas I do if it turns out to be amoty or an expression.

There is another problem that's perhaps unique to the current implementation, which is that, if you remmeber, when parsing statements divorced from parsing variable declarations, `parse_stmt` moved into its own home, whule parsing declarations still clung to the old home of `parse_block_item`. Now that variable declarations have a new partner, they need to move to their own home. The divorce is finally complete.

```zig
fn parse_block_item(
    arena: std.mem.Allocator,
    tokens: *lexer.Tokenizer,
) Error!ast.BlockItem {
    const current = tokens.next() orelse
        return error.NotEnoughJunk;
    tokens.put_back(current);

    switch (current.tag) {
        .type_int => return .decl(try parse_var_decl(arena, tokens)),
        else => return .stmt(try parse_stmt(arena, tokens)),
    }
}

fn parse_var_decl(
    arena: std.mem.Allocator,
    tokens: *lexer.Tokenizer,
) Error!ast.Decl {
    try expect(.type_int, tokens);
    const name = try expect(.identifier, tokens);
    const new_token = tokens.next() orelse
        return error.NotEnoughJunk;

    const init: ?*ast.Expr = switch (new_token.tag) {
        .equals => ret: {
            const expr = try parse_expr(arena, tokens, 0);
            const expr_ptr = try utils.create(arena, expr);

            try expect(.semicolon, tokens);
            break :ret expr_ptr;
        },
        .semicolon => null,
        else => return error.SyntaxError,
    };

    return .{ .name = name, .init = init };
}
```

Now that I am properly equipped, time to take on `for`. After the left parenthesis, take it one piece at a time. First is `init`:

```zig
// I needed the type here so I had to name it and make it pub in the AST
const init: ast.Stmt.For.Init = init: {
    const new_token = tokens.next() orelse
        return error.NotEnoughJunk;
    switch (new_token.tag) {
        .semicolon => break :init .none,
        .type_int => {
            tokens.put_back(new_token);
            const decl = try parse_var_decl(arena, tokens);
            const decl_ptr = try utils.create(arena, decl);
            break :init .{ .decl = decl_ptr };
        },
        else => {
            tokens.put_back(new_token);
            const expr = try parse_expr(arena, tokens, 0);
            const expr_ptr = try utils.create(arena, expr);
            try expect(.semicolon, tokens);
            break :init .{ .expr = expr_ptr };
        },
    }
};
```

The other two are tamer beasts. A small difference between `cond` and `post` is the `post` does not require a semicolon to terminate it, so it is compared to the right parenthesis instead.

```zig
const cond: ?*ast.Expr = cond: {
    const new_token = tokens.next() orelse
        return error.NotEnoughJunk;
    switch (new_token.tag) {
        .semicolon => break :cond null,
        else => {
            tokens.put_back(new_token);
            const expr = try parse_expr(arena, tokens, 0);
            const expr_ptr = try utils.create(arena, expr);
            try expect(.semicolon, tokens);
            break :cond expr_ptr;
        },
    }
};
const post: ?*ast.Expr = post: {
    const new_token = tokens.next() orelse
        return error.NotEnoughJunk;
    switch (new_token.tag) {
        .r_paren => break :post null,
        else => {
            tokens.put_back(new_token);
            const expr = try parse_expr(arena, tokens, 0);
            const expr_ptr = try utils.create(arena, expr);
            try expect(.r_paren, tokens);
            break :post expr_ptr;
        },
    }
};
```

Then finally, the coup de grace:

```zig
const body = try parse_stmt(arena, tokens);
const body_ptr = try utils.create(arena, body);

return .{ .@"for" = .{
    .init = init,
    .cond = cond,
    .post = post,
    .body = body_ptr,
    .label = null,
} };
```

This about covers it I thnk. One tiny complication remains: in implementing the pretty printer last chapter, I used the keyword `DO` for blocks. So instead of repeating myself, I am going to use a differrent keyword for `do while` loops: `UNTIL`. These look fine. Time to move on.

```c
int main(void) {
    int sum = 0;
    for (int i = 0; i < 10;) {
        i = i + 1;
        if (i % 2)
            continue;
        sum = sum + i;
    }
    return sum;
}

// PRORGAM
// 	FUNCTION main
// 		int sum <- 0
// 		FOR int i <- 0; (< i 10); ---
// 			(i <- (+ i 1));
// 			IF (% i 2)
// 				CONTINUE
// 			(sum <- (+ sum i));
// 		RETURN sum
```

```c
int main(void) {
    int a = 1;
    do {
        a = a * 2;
    } while(a < 11);

    return a;
}

// PRORGAM
// 	FUNCTION main
// 		int a <- 1
// 		UNTIL (< a 11)
// 			(a <- (* a 2));
// 		RETURN a
```

## Semantic Analysis

In addition to variable resolution, this chapter will also do loop labelling, attaching each `break` and `continue` to thier parent loops. While C does not have labelled loops, `goto` aside, this is still needed to generate the proper labels for IR and assembly `jump` instructions.

Resolving variables in `while` and `do while` is fairly simple, just like an `if` statement. `break` and `continue` have nothing to resolve. `for` loops, are, once again, more complicated. A new scope is introduced, similarly to compound statements, _on top of_ the scope introduced by the inner compound stattement. Instead of duplicating the boilerplate, I thought to combine `for` statements and `compound` statements into one branch as follows:

```zig
.@"for", .compound => {
    var variable_map = try bp.variable_map.clone(bp.gpa);
    defer variable_map.deinit(bp.gpa);

    var iter = variable_map.valueIterator();
    while (iter.next()) |value|
        value.* = .{ .name = value.name, .scope = .parent };

    const inner_bp: Boilerplate = .{
        .gpa = bp.gpa,
        .strings = bp.strings,
        .variable_map = &variable_map,
    };

    switch (stmt.*) {
        .compound => |*b| try resolve_block(inner_bp, b),
        .@"for" => |f| {
            switch (f.init) {
                .decl => |d| try resolve_decl(inner_bp, d),
                .expr => |e| try resolve_expr(inner_bp, e),
                .none => {},
            }
            if (f.cond) |c| try resolve_expr(inner_bp, c);
            if (f.post) |p| try resolve_expr(inner_bp, p);
            try resolve_stmt(inner_bp, f.body);
        },
        else => unreachable,
    }
},
```

Regarding loop labelling, the Book does this in a separate pass from variable resolution. I do not particularly feel like creating yet another file (as I have each compiler pass in its own file), so I will try to do it within `resolve_stmt`. After all, all the related structures are statements.

Since it is being called recursively, an additional parameter is needed. I will pass it separately to avoid updating the `Boilerplate` struct for every time `resolve_stmt` is called, which would, ironically, increase the boilerplate.

This is the new `resolve_stmt` in all its glory.

```zig
fn resolve_stmt(
    bp: Boilerplate,
    current_label: ?[:0]const u8,
    stmt: *ast.Stmt,
) Error!void {
    switch (stmt.*) {
        .null => {},
        .@"break", .@"continue" => |*l| l.* = current_label orelse
            return error.BreakOutsideLoop,
        .@"return", .expr => |expr| try resolve_expr(bp, expr),
        .@"if" => |i| {
            try resolve_expr(bp, i.cond);
            try resolve_stmt(bp, current_label, i.then);
            if (i.@"else") |e|
                try resolve_stmt(bp, current_label, e);
        },
        .@"while", .do_while => |*w| {
            const label = try bp.make_temporary("while");
            w.label = label; // forgot this on the first pass!
            try resolve_expr(bp, w.cond);
            try resolve_stmt(bp, label, w.body);
        },
        .@"for", .compound => {
            var variable_map = try bp.variable_map.clone(bp.gpa);
            defer variable_map.deinit(bp.gpa);

            var iter = variable_map.valueIterator();
            while (iter.next()) |value|
                value.* = .{ .name = value.name, .scope = .parent };

            const inner_bp: Boilerplate = .{
                .gpa = bp.gpa,
                .strings = bp.strings,
                .variable_map = &variable_map,
            };

            switch (stmt.*) {
                .compound => |*b| try resolve_block(inner_bp, current_label, b),
                .@"for" => |*f| {
                    const label = try bp.make_temporary("for");
                    f.label = label;
                    switch (f.init) {
                        .decl => |d| try resolve_decl(inner_bp, d),
                        .expr => |e| try resolve_expr(inner_bp, e),
                        .none => {},
                    }
                    if (f.cond) |c| try resolve_expr(inner_bp, c);
                    if (f.post) |p| try resolve_expr(inner_bp, p);
                    try resolve_stmt(inner_bp, label, f.body);
                },
                else => unreachable,
            }
        },
    }
}
```

With tiny related adjustments to `resolve_block`'s body and signature and `resolve_func_def`'s body, the code is good to go. The Eye Test I set up a couple of chapter earlier allowed me to catch that I was not _actually_ assigning the labels to the blocks, a mistake I would not have caught otherwise until much later.

---

## IR Generation
