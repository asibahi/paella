# Writing a C Compiler - Chapter 8 - in Zig

<!-- Done Date: 2025-05-25 -->

[Seven](c7.md) done of [Writing a C Compiler](https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html), a few more to go. Now is the time for loops.

---

## Lexer, AST and Parser

The lexer is just a few new keywords. Been there, done that. Changes to the AST are more interesting. No less than five new statements, one for every new keyword. Here is the new `Stmt` without further ado:

```zig
pub const Stmt = union(enum) {
    @"return": *Expr,
    expr: *Expr,
    @"if": struct { cond: *Expr, then: *Stmt, @"else": ?*Stmt },
    compound: Block,
    @"break": ?[:0]const u8,
    @"continue": ?[:0]const u8,
    @"while": While,
    do_while: While,
    @"for": For,
    null: void,

    const While = struct {
        cond: *Expr,
        body: *Stmt,
        label: ?[:0]const u8,
    };

    pub const For = struct {
        label: ?[:0]const u8,
        init: Init,
        cond: ?*Expr,
        post: ?*Expr,
        body: *Stmt,

        pub const Init = union(enum) { decl: *Decl, expr: *Expr, none },
    };
}
```

A few notes. Each of there statements have an optional label argument. This label is used later to associate `break`s and `continue`s with their associated loops during semantic analysis. You cannot actually assign labels to loops in C as far as I know.

Also, usually for a one off subtype like `For` here, I put it inline. But this one is big and hairy and has a subtype of its own that it warrants the spcial treatment. `Init` itself is named because I am naming it later in the parser. To map the fields to the actualy `for` loop in code, it is basically this:

```c
for (init, cond, post) body
```

All the three first fields are optional. The reason that `none` is a state of `init` instead of using an optional is shave a few bytes from the size of `init` (and therefore the whole `For` type and then the whole `Stmt` type).

Parsing these are a bit more interesting. First, the straightforward `break` and `continue`.

```zig
.keyword_break => {
    try expect(.semicolon, tokens);
    return .{ .@"break" = null };
},
.keyword_continue => {
    try expect(.semicolon, tokens);
    return .{ .@"continue" = null };
},
```

`while` and `do while` are slightly more interesting. They're similar to `if`.

```zig
.keyword_while => {
    try expect(.l_paren, tokens);
    const cond = try parse_expr(arena, tokens, 0);
    const cond_ptr = try utils.create(arena, cond);
    try expect(.r_paren, tokens);

    const body = try parse_stmt(arena, tokens);
    const body_ptr = try utils.create(arena, body);

    return .{ .@"while" = .{
        .cond = cond_ptr,
        .body = body_ptr,
        .label = null,
    } };
},
.keyword_do => {
    const body = try parse_stmt(arena, tokens);
    const body_ptr = try utils.create(arena, body);

    try expect(.keyword_while, tokens);
    try expect(.l_paren, tokens);
    const cond = try parse_expr(arena, tokens, 0);
    const cond_ptr = try utils.create(arena, cond);
    try expect(.r_paren, tokens);
    try expect(.semicolon, tokens);

    return .{ .do_while = .{
        .cond = cond_ptr,
        .body = body_ptr,
        .label = null,
    } };
},
```

Now time for the final boss. `for`. There is a funny complication here that I hit on my previous Rust implementation. The parsing code for variable declarations already expects a semicolon, but the one for expressions _does not_. So if I determine the `init` statement is a variable declaration, I need not check for a semicolon, whereas I do if it turns out to be amoty or an expression.

There is another problem that's perhaps unique to the current implementation, which is that, if you remmeber, when parsing statements divorced from parsing variable declarations, `parse_stmt` moved into its own home, whule parsing declarations still clung to the old home of `parse_block_item`. Now that variable declarations have a new partner, they need to move to their own home. The divorce is finally complete.

```zig
fn parse_block_item(
    arena: std.mem.Allocator,
    tokens: *lexer.Tokenizer,
) Error!ast.BlockItem {
    const current = tokens.next() orelse
        return error.NotEnoughJunk;
    tokens.put_back(current);

    switch (current.tag) {
        .type_int => return .decl(try parse_var_decl(arena, tokens)),
        else => return .stmt(try parse_stmt(arena, tokens)),
    }
}

fn parse_var_decl(
    arena: std.mem.Allocator,
    tokens: *lexer.Tokenizer,
) Error!ast.Decl {
    try expect(.type_int, tokens);
    const name = try expect(.identifier, tokens);
    const new_token = tokens.next() orelse
        return error.NotEnoughJunk;

    const init: ?*ast.Expr = switch (new_token.tag) {
        .equals => ret: {
            const expr = try parse_expr(arena, tokens, 0);
            const expr_ptr = try utils.create(arena, expr);

            try expect(.semicolon, tokens);
            break :ret expr_ptr;
        },
        .semicolon => null,
        else => return error.SyntaxError,
    };

    return .{ .name = name, .init = init };
}
```

Now that I am properly equipped, time to take on `for`. After the left parenthesis, take it one piece at a time. First is `init`:

```zig
// I needed the type here so I had to name it and make it pub in the AST
const init: ast.Stmt.For.Init = init: {
    const new_token = tokens.next() orelse
        return error.NotEnoughJunk;
    switch (new_token.tag) {
        .semicolon => break :init .none,
        .type_int => {
            tokens.put_back(new_token);
            const decl = try parse_var_decl(arena, tokens);
            const decl_ptr = try utils.create(arena, decl);
            break :init .{ .decl = decl_ptr };
        },
        else => {
            tokens.put_back(new_token);
            const expr = try parse_expr(arena, tokens, 0);
            const expr_ptr = try utils.create(arena, expr);
            try expect(.semicolon, tokens);
            break :init .{ .expr = expr_ptr };
        },
    }
};
```

The other two are tamer beasts. A small difference between `cond` and `post` is the `post` does not require a semicolon to terminate it, so it is compared to the right parenthesis instead.

```zig
const cond: ?*ast.Expr = cond: {
    const new_token = tokens.next() orelse
        return error.NotEnoughJunk;
    switch (new_token.tag) {
        .semicolon => break :cond null,
        else => {
            tokens.put_back(new_token);
            const expr = try parse_expr(arena, tokens, 0);
            const expr_ptr = try utils.create(arena, expr);
            try expect(.semicolon, tokens);
            break :cond expr_ptr;
        },
    }
};
const post: ?*ast.Expr = post: {
    const new_token = tokens.next() orelse
        return error.NotEnoughJunk;
    switch (new_token.tag) {
        .r_paren => break :post null,
        else => {
            tokens.put_back(new_token);
            const expr = try parse_expr(arena, tokens, 0);
            const expr_ptr = try utils.create(arena, expr);
            try expect(.r_paren, tokens);
            break :post expr_ptr;
        },
    }
};
```

Then finally, the coup de grace:

```zig
const body = try parse_stmt(arena, tokens);
const body_ptr = try utils.create(arena, body);

return .{ .@"for" = .{
    .init = init,
    .cond = cond,
    .post = post,
    .body = body_ptr,
    .label = null,
} };
```

This about covers it I thnk. One tiny complication remains: in implementing the pretty printer last chapter, I used the keyword `DO` for blocks. So instead of repeating myself, I am going to use a differrent keyword for `do while` loops: `UNTIL`. These look fine. Time to move on.

```c
int main(void) {
    int sum = 0;
    for (int i = 0; i < 10;) {
        i = i + 1;
        if (i % 2)
            continue;
        sum = sum + i;
    }
    return sum;
}

// PRORGAM
// 	FUNCTION main
// 		int sum <- 0
// 		FOR int i <- 0; (< i 10); ---
// 			(i <- (+ i 1));
// 			IF (% i 2)
// 				CONTINUE
// 			(sum <- (+ sum i));
// 		RETURN sum
```

```c
int main(void) {
    int a = 1;
    do {
        a = a * 2;
    } while(a < 11);

    return a;
}

// PRORGAM
// 	FUNCTION main
// 		int a <- 1
// 		UNTIL (< a 11)
// 			(a <- (* a 2));
// 		RETURN a
```

## Semantic analysis
