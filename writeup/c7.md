# Writing a C Compiler - Chapter 7 - in Zig

<!-- Done Date: 2025-05-24 -->

Chapter 6 of [Writing a C Compiler](https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html) was a short one. So will Chapter 7. Do not even bother to buckle up.

---

## Syntax Tree and Parsing

See? Not even new tokens for lexer.

This chapter is all about implementing compound statements. To abstract the similarities between a function body and compound statements, a new `Block` AST node shall be created. Along with a tiny change in `FuncDef`, you get this beauty.

```zig
pub const FuncDef = struct {
    name: []const u8,
    body: Block,
};

pub const Block = struct {
    body: std.SegmentedList(BlockItem, 0),
};
```

And adding a new statment type in `Stmt`.

```zig
pub const Stmt = union(enum) {
    @"return": *Expr,
    expr: *Expr,
    @"if": struct { cond: *Expr, then: *Stmt, @"else": ?*Stmt },
    compound: Block, // <-- this one
    null: void,
};
```

I _think_ it does not need a pointer. I will wait to see if the Zig compiler yells at me.

Updating the parser requires a new function: `parse_block`. It is simple enough and the implementation is copied over from `parse_func_def`.

```zig
fn parse_block(
    arena: std.mem.Allocator,
    tokens: *lexer.Tokenizer,
) Error!ast.Block {
    try expect(.l_brace, tokens);

    var body: std.SegmentedList(ast.BlockItem, 0) = .{};

    while (tokens.next()) |next_token| {
        if (next_token.tag == .r_brace) break;
        tokens.put_back(next_token);

        const item = try parse_block_item(arena, tokens);
        try body.append(arena, item);
    } else return error.NotEnoughJunk;

    return .{ .body = body };
}
```

And `parse_func_def` is adjusted accordingly:

```zig
fn parse_func_def(
    arena: std.mem.Allocator,
    tokens: *lexer.Tokenizer,
) Error!ast.FuncDef {
    try expect(.type_int, tokens);

    const name = try expect(.identifier, tokens);

    try expect(.l_paren, tokens);
    try expect(.keyword_void, tokens);
    try expect(.r_paren, tokens);

    const block = try parse_block(arena, tokens);

    return .{ .name = name, .block = block };
}
```

And that is it.

## Pretty Printing Tricks

I encountered an interesting problem in the AST pretty printer. Because I am using an indentation based scheme, rather than braces, it makes it slightly difficult to know where blocks begin and end if I just, increase the indentation. So, for a regular block, I add the keyword `DO`.

```c
int main(void) {
    int a = 2;
    int b;
    {
        a = -4;
        int a = 7;
        b = a + 1;
    }
    return b == 8 && a == -4;
}
```

```
PRORGAM
	FUNCTION main
		int a <- 2;
		int b;
		DO
			a <- (- 4);
			int a <- 7;
			b <- (+ a 1);
		RETURN (&& (== b 8) (== a (- 4)))
```

But when the block is in the `if` statement, this would look something like this, which is .. eh, unseemly.

```
IF a
	DO
		int b <- 2;
		RETURN b
```

So instead I get rid of `DO` and just have indent immediately after `IF`. The thing is, the logic for compound statement printing does not know, normally, whether it is preceded by `IF` (and later `FOR` and `WHILE`), or if it standing by its own. Doing the custom formatting when printing `IF` would lead to a lot of duplicated code for every new control flow statement. So time to abuse another feature of the formatter!

One of the options in `srd.fmt.FormatOptions` is `alignment`, which is normally used to align the printed items right, left, or center, within given padding. In the `fmt` string, `<` indicated left, `^` indicates center, and `>` indicates right, which is the default value.

In other words, when printing the statement following `IF`, all I need to do there is this, which sets the `alignment` option in the called function to `.center`.

```zig
try writer.print("{:^[1]}", .{ cs.then, w + 1 });
//                  ^ right here
```

And now I can do the check right within `.compound`:

```zig
.compound => |b| {
    var iter = b.body.constIterator(0);

    var cw: usize = undefined;
    if (options.alignment != .center) { // <-- here
        try writer.writeAll("DO");
        cw = w + 1;
    } else {
        if (iter.next()) |item|
            try writer.print("{}", .{item});
        cw = w;
    }

    while (iter.next()) |item| {
        try writer.print("\n{:[1]}", .{
            item,
            cw,
        });
    }
},
```

The other issue, which you might have noticed is, is that the new line characters which separate the internal block items are printed before each statement. The reason for that is for the block not to end in a newline character, as the new line is usually taken care of by the _parent_ block. This simply avoids an additional blank line after every block.

This prints the AST nicely, even for ridiculous C code.

```c
int main(void) {
    int ten = 10;
    {}
    int twenty = 10 * 2;
    {{}}
    return ten + twenty;
}
```

```
PRORGAM
	FUNCTION main
		int ten <- 10;
		DO
		int twenty <- (* 10 2);
		DO
			DO
		RETURN (+ ten twenty)
```

I could just as well omit the empty blocks right here and then.[^python]. Maybe I will do that if I ever write a real compiler.

[^python]: Or pull a Python and output `...` or `pass`.

## Semantic Analysis

I wish this were as easy as filling up the blanks, but that is actually where the meat of this chapter is. C allows shadowing, see?
