# Writing a C Compiler - Chapter 7 - in Zig

<!-- Done Date: 2025-05-24 -->

Chapter 6 of [Writing a C Compiler](https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html) was a short one. So will Chapter 7. Do not even bother to buckle up.

---

## Syntax Tree and Parsing

See? Not even new tokens for lexer.

This chapter is all about implementing compound statements. To abstract the similarities between a function body and compound statements, a new `Block` AST node shall be created. Along with a tiny change in `FuncDef`, you get this beauty.

```zig
pub const FuncDef = struct {
    name: []const u8,
    body: Block,
};

pub const Block = struct {
    body: std.SegmentedList(BlockItem, 0),
};
```

And adding a new statment type in `Stmt`.

```zig
pub const Stmt = union(enum) {
    @"return": *Expr,
    expr: *Expr,
    @"if": struct { cond: *Expr, then: *Stmt, @"else": ?*Stmt },
    compound: Block, // <-- this one
    null: void,
};
```

I *think* it does not need a pointer. I will wait to see if the Zig compiler yells at me.

Updating the parser requires a new function: `parse_block`. It is simple enough and the implementation is copied over from `parse_func_def`.

```zig
fn parse_block(
    arena: std.mem.Allocator,
    tokens: *lexer.Tokenizer,
) Error!ast.Block {
    try expect(.l_brace, tokens);

    var body: std.SegmentedList(ast.BlockItem, 0) = .{};

    while (tokens.next()) |next_token| {
        if (next_token.tag == .r_brace) break;
        tokens.put_back(next_token);

        const item = try parse_block_item(arena, tokens);
        try body.append(arena, item);
    } else return error.NotEnoughJunk;

    return .{ .body = body };
}
```

And `parse_func_def` is adjusted accordingly:

```zig
fn parse_func_def(
    arena: std.mem.Allocator,
    tokens: *lexer.Tokenizer,
) Error!ast.FuncDef {
    try expect(.type_int, tokens);

    const name = try expect(.identifier, tokens);

    try expect(.l_paren, tokens);
    try expect(.keyword_void, tokens);
    try expect(.r_paren, tokens);

    const block = try parse_block(arena, tokens);

    return .{ .name = name, .block = block };
}
```

And that is it.

## Pretty Printing Tricks

I encountered an interesting problem in the AST pretty printer.
