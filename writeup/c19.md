# Writing a C Compiler, Chapter 19, in Zig

<!-- Done Date: 2025-06-04 -->

Whoa whoa.. we were just in [chapter 10](c10.md) of [Writing a C Compiler](https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html): how did we jump to chapter 19 so fast? The answer is that I skipped these pesky chapters about implementing types in the middle, and jumped straight to Part 3, which is abput optimizations.

I have not actually read those chapters before, so now is the time! This chapter seems to be about machine-independent (read: IR) optimizations: constant folding and what have you.

---

## Compiler Driver

The first task in this chapter is to update the compiler driver, and what flags it can take. This a bit more complex than how I originally implemented it, because now multiple flags for different optimization passes can be combined. And it needs assembly in stdout. I might end up getting out of this project with my own argument parsing library. Anyway, this is the current implementation in full.

```zig
const Args = struct {
    path: [:0]const u8,
    mode: Mode,
    c_flag: bool,
};

const Mode = enum {
    lex,
    parse,
    validate,
    tacky,
    codegen,
    compile, // default
    assembly, // unused by test script - useful for debugging
};

fn parse_args() !Args {
    var args = std.process.args();
    _ = args.skip();

    var path: ?[:0]const u8 = null;
    var mode: Mode = .compile;
    var c_flag = false;

    while (args.next()) |arg| {
        if (arg[0] == '-') {
            if (arg[1] == 'c')
                c_flag = true
            else
                mode = std.meta.stringToEnum(Mode, arg[2..]) orelse
                    return error.UnrecognizedFlag;
        } else if (path == null)
            path = arg
        else
            return error.PathDuplicated;
    }

    return .{
        .path = path orelse return error.PathNotFound,
        .mode = mode,
        .c_flag = c_flag,
    };
}
```

The new options to add are as follows: `-S` to generate an assembly file but stop short of linking it and compiling it. The existing `assembly` options (which I used to view assembly output) merely prints to standard error. The other flags can be combined: `--fold-constants`, `--propagate-copies`, `--eliminate-unreachable-code` (a mouthful), `--eliminate-dead-stores`, and finally `--optimize` which enables all four options. These would be passed to the optimization state.

This calls for bitsets! Where is Odin when you need it? The Zig standard library thankfully has a nice that replicates Odin's really cool bitsets: `EnumSet`.[^rust] This would go with another enum of optimizations, that I decided to encode dashes and all to avoid any unwanted behaviour in `stringToEnum`. Better be literal! This is the new function with the changes highlighted.

[^rust]: Also there is a cool Rust library with that name that does the same thing with proc macro magic. It used to be in the standard library but was culled unfairly.

```zig
const Args = struct {
    path: [:0]const u8,
    mode: Mode,
    c_flag: bool,
    optimizations: std.EnumSet(Optimization), // new field!
};

const Mode = enum {
    lex,
    parse,
    validate,
    tacky,
    codegen,
    compile, // default
    assembly,
    output_assembly, // <-- -S : generate an assembly file
};

const Optimization = enum { // <-- new type. moves to ir_opt.zig
    @"fold-constants",
    @"propagate-copies",
    @"eliminate-unreachable-code",
    @"eliminate-dead-stores",
};

fn parse_args() !Args {
    var args = std.process.args();
    _ = args.skip();

    var path: ?[:0]const u8 = null;
    var mode: Mode = .compile;
    var c_flag = false;
    var optimizations: std.EnumSet(Optimization) = .initEmpty(); // <-- fill this

    while (args.next()) |arg| {
        if (arg[0] == '-') {
            if (arg[1] == 'c')
                c_flag = true
            else if (arg[1] == 'S' or arg[1] == 's') // <-- what if it is a typo?
                mode = .output_assembly
            else if (std.meta.stringToEnum(Mode, arg[2..])) |m|
                mode = m
            else if (std.meta.stringToEnum(Optimization, arg[2..])) |opt| // <--
                optimizations.insert(opt)
            else if (std.mem.eql(u8, "optimize", arg[2..])) // <-- with everything
                optimizations = .initFull()
            else
                return error.UnrecognizedFlag;
        } else if (path == null)
            path = arg
        else
            return error.PathDuplicated;
    }

    return .{
        .path = path orelse return error.PathNotFound,
        .mode = mode,
        .c_flag = c_flag,
        .optimizations = optimizations, // <--
    };
}
```

This then gets threaded into the `run` function as needed. I will not bore you with the details.

## The Optimizer

The Optimizer takes an `ir.FuncDef` and the `Optimization` `EnumSet` and keeps applying the provided optimizations until there are no more changes. Sounds interesting, but how do I make it so comparing old and new function definitions is as fast as possible? Do I just use `std.mem.eql`? This is the current definition of `ir.FuncDef`.

```zig
pub const FuncDef = struct {
    name: Identifier,
    global: bool = false, // assigned later than contruction
    params: std.ArrayListUnmanaged(Identifier),
    instrs: std.ArrayListUnmanaged(Instr),

    fn deinit(self: *@This(), alloc: std.mem.Allocator) void {
        for (self.instrs.items) |*i| i.deinit(alloc);
        self.params.deinit(alloc);
        self.instrs.deinit(alloc);
    }
};
```

I am more or less thinking aloud here, so bear with me. No point in comparing `name`, `global`, or `params`, as they will not be affected by the optimizations in the Book. Only `instrs`, which is, if you dig enough in the code, is a struct of a slice and capacoity. No point in comparing the capacity, so comparing the two slices of `Instr` should be enough. Comaprings the lengths of slices is pointedly _not_ enough because not all optimizations change the length.

But wait, I hear you say, could you not just return whether the optimization pass made a change at all? That actually sounds simpler, to be honest. I think I will go with that.

Adapting the Book's pseudocode to Zig gives the following. This is just a draft with stubs, mind you: a place to start with.

```zig
pub fn optimize(
    gpa: std.mem.Allocator,
    instrs: std.ArrayListUnmanaged(ir.Instr),
    opts: std.EnumSet(Optimization),
) std.ArrayListUnmanaged(ir.Instr) {
    if (instrs.items.len == 0) return instrs;

    var work = true;
    while (work) {
        work = false;

        const folded_instrs =
            if (opts.contains(.@"fold-constants")) lbl: {
                work = true; // obviously wrong. this is a draft
                break :lbl fold_constants(gpa, instrs);
            } else instrs;

        var cfg = make_control_flow_graph(gpa, folded_instrs);

        if (opts.contains(.@"eliminate-unreachable-code")) {
            work = true;
            cfg = eliminate_unreachable_code(gpa, cfg);
        }

        if (opts.contains(.@"propagate-copies")) {
            work = true;
            cfg = propagate_copies(gpa, cfg);
        }

        if (opts.contains(.@"eliminate-dead-stores")) {
            work = true;
            cfg = eliminate_dead_stores(gpa, cfg);
        }

        const ret_instrs = cfg_to_instrs(cfg);
        if (ret_instrs.items.len == 0 or !work) {
            return ret_instrs;
        }

        instrs = ret_instrs;
    }
}
```

Obviously setting `work` to `true` right there is wrong. This could be informed by the child funtions whether they made a change or not. But this is a draft, and I will figure out how this looks like later.

Of interest here is that only the first pass works on instrutions immediately, while the rest operate on a control flow graph.

## Constant Folding

With the stub filled up, time to flesh out the constant folding pass. This will work in a similar manner to how the instruction fixup pass works: a new empty `ArrayList` will be created, and filled up with instructions one by one, then the old `ArrayList` is a deallocated and the new one is returned in its stead.

Copying the signature and the main structure of that function gives me the following stub. It is already different to my assumptions in the previous listing, but that is ok.

```zig
fn fold_constants(
    gpa: std.mem.Allocator,
    func_def: *ir.FuncDef,
) !bool {
    var out: std.ArrayListUnmanaged(ir.Instr) = try .initCapacity(
        gpa,
        func_def.instrs.capacity,
    );
    defer {
        std.mem.swap(
            std.ArrayListUnmanaged(ir.Instr),
            &out,
            &func_def.instrs,
        );
        out.deinit(gpa);
    }

    var work = false;

    for (func_def.instrs.items) |instr| {
        // todo
    }

    return work;
}
```

The pass would evaluate all binary and unary instructions, and the two conditional jumps. For example, this is how it would work for `binop_add` and `jump_z`.

```zig
switch (instr) {
    .binop_add => |b| if (b.src1 == .constant and b.src2 == .constant) {
        work = true;
        const res: ir.Value =
            .{ .constant = b.src1.constant +% b.src2.constant };
        try out.append(gpa, .{ .copy = .init(res, b.dst) });
    } else try out.append(gpa, instr),

    .jump_z => |j| if (j.cond == .constant) {
        work = true;
        if (j.cond.constant == 0)
            try out.append(gpa, .{ .jump = j.target });
    } else try out.append(gpa, instr),

    // the rest of the instructions
}
```

This looks simple enough, if it is a bit of a slog.[^llm] I will spare writing every line of this large switch. There is nothing particularly illuminating. The use of the `+%` operator is to fend against integer overflow, which is undefined behavious in C. Here I am choosing to simply wrap it like a sane person would.

[^llm]: I am sure I can get an Agent to spare me the misery but the misery is the point.

This is it for constant folding apparently. There is other stuff to do if I had gone through Part 2 and added other types, but I have not, so there is not. Doing the wiring is fairly tedious work that I am not going to write here. The draft optimization loop above has changed to this:

```zig
pub fn optimize(
    gpa: std.mem.Allocator,
    func_def: *ir.FuncDef,
    opts: std.EnumSet(Optimization),
) !void {
    if (func_def.instrs.items.len == 0) return;

    while (true) {
        var work_done = false;

        if (opts.contains(.@"fold-constants"))
            work_done = try fold_constants(gpa, func_def) or work_done;

        // var cfg = make_control_flow_graph(gpa, func_def.instrs);

        // if (opts.contains(.@"eliminate-unreachable-code")) {
        //     work_done = true;
        //     cfg = eliminate_unreachable_code(gpa, cfg);
        // }

        // if (opts.contains(.@"propagate-copies")) {
        //     work_done = true;
        //     cfg = propagate_copies(gpa, cfg);
        // }

        // if (opts.contains(.@"eliminate-dead-stores")) {
        //     work_done = true;
        //     cfg = eliminate_dead_stores(gpa, cfg);
        // }

        // const ret_instrs = cfg_to_instrs(cfg);

        if (func_def.instrs.items.len == 0 or !work_done)
            return;

        // instrs = ret_instrs;
    }
}
```

One annoyance I had to deal with: in other to make sure the correct addition and negation semantics, I had to change the type I am using to store integers throughout the codebase from a `u64` (which is generically useful) to `i32`. Zig makes dealing with numerical code very onerous. Also did you know you cannot use the `/` and `%` operators for signed integers? I did not, but the compiler told me!

Running the tests has them all pass. Excellent. I am unsure what wizardry the tests do to ascertain that I have constant folded correctly, but if they tell me I am good then I am good.[^readme] Moving on.

[^readme]: Oh there is a `README` that explains it. It works by checking for _any_ binary operations in certain functions. Clever, to be honest.

## Control Flow Graphs

The remaining optimizations passes require a [Control Flow Graph](https://en.wikipedia.org/wiki/Control-flow_graph) (henceforth CFG). The Book does not provide a complete implementation, but it does offer pointers and ideas on how to generalize it (as it would be used for assembly instructions next chapter). Zig does not have, apparently, a blessed graph library like Rust's [`petgraph`](https://docs.rs/petgraph/latest/petgraph/). So I would have to implement my own.

Producing a CFG with this IR is simple enough: since the IR uses instructions like `label` and `jump`, building the basic blocks is relatively easy. And since the blocks are produced in order, concatenating them back into a function body is straightforward. Creating the edges between the blocks is a bit harder, however.

The first draft of the CFG looks something like the following.

```zig
// generic!
fn ControlFlowGraph(Instr: type) type {
    return struct {
        const Node = union(enum) {
            entry,
            exit,
            basic_block: std.ArrayListUnamanged(Instr),
        };

        nodes: std.ArrayListUnmanaged(Node),
        // each edge is an ordered pair of two indices of nodes.
        edges: std.ArrayListUnmanaged(struct { usize, usize }),

        // todo the rest
        //
    };
}
```

The idea here is that each Node is identified in `nodes` by its index. I need to also a way to find blocks based on the `label` they start with, but that could ne just done ad-hoc.

There are two parts to initializing the CFG: partitioning the instruction list into basic blocks, then creating the edges between them. It would be a mistake to assume all subsequent blocks are linked, since they might end in a jump.

As an aside note, to keep the structure generic over IR instructions and assembly instructions, the book suggested to create a helper type called `GenericInstr`. It looks like this.

```zig
pub const GenericInstr = union(enum) {
    ret,
    jmp: StringInterner.Idx,
    cond_jmp: StringInterner.Idx,
    label: StringInterner.Idx,
    other,
};
```

And then in `ir.Instr` I would add the following method. Yay for duck typing! The method for `assembly.Instr` would have to wait until next chapter. The real question is: why am I even torturing myself making the CFG generic right _now_?

```zig
pub fn to_generic(
    self: @This(),
) utils.GenericInstr {
    return switch (self) {
        .ret => .ret,
        .jump => |l| .{ .jmp = l },
        .jump_z, .jump_nz => |j| .{ .cond_jmp = j.target },
        .label => |l| .{ .label = l },
        else => .other,
    };
}
```

The whole process culminates in an absolutely humongous `init` function. This is it.

```zig
pub fn init(
    gpa: std.mem.Allocator,
    instrs: std.ArrayListUnmanaged(Instr),
) !@This() {
    var nodes: std.ArrayListUnmanaged(Node) = .empty;
    try nodes.append(gpa, .entry);

    { // partition basic blocks
        var current_node: Node = .{ .basic_block = .empty };
        for (instrs.items) |instr| switch (instr.to_generic()) {
            .label => {
                if (current_node.basic_block.items.len > 0)
                    try nodes.append(gpa, current_node);

                current_node = .{ .basic_block = .empty };
                try current_node.basic_block.append(gpa, instr);
            },
            .ret, .jmp, .cond_jmp => {
                try current_node.basic_block.append(gpa, instr);
                try nodes.append(gpa, current_node);

                current_node = .{ .basic_block = .empty };
            },
            .other => try current_node.basic_block.append(gpa, instr),
        };
        try nodes.append(gpa, .exit);
    }

    var edges: std.ArrayListUnmanaged(struct { usize, usize }) = .empty;
    { // adding edges
        // entry to block 1.
        try edges.append(gpa, .{ 0, 1 });
        const exit_idx = nodes.items.len - 1;

        for (nodes.items, 0..) |node, idx| if (node == .basic_block) {
            const gen: GenericInstr = node.basic_block.getLast().to_generic();
            switch (gen) {
                .ret => try edges.append(gpa, .{ idx, exit_idx }),
                .other, .label => try edges.append(gpa, .{ idx, idx + 1 }),
                .jmp, .cond_jmp => |l| {
                    const target_idx = for (nodes.items, 0..) |n, i| {
                        if (n == .basic_block) {
                            const fst = n.basic_block.items[0].to_generic();
                            if (fst == .label and fst.label.real_idx == l.real_idx)
                                break i;
                        }
                    } else unreachable;

                    try edges.append(gpa, .{ idx, target_idx });
                    if (gen == .cond_jmp)
                        try edges.append(gpa, .{ idx, idx + 1 });
                },
            }
        };
    }

    return .{
        .nodes = nodes,
        .edges = edges,
    };
}

// and its tiny brother
pub fn deinit(
    self: *@This(),
    gpa: std.mem.Allocator,
) void {
    for (self.nodes.items) |*node| switch (node.*) {
        .basic_block => |*l| l.deinit(gpa),
        else => {},
    };
    self.nodes.deinit(gpa);
    self.edges.deinit(gpa);
}
```

To be used thus. (I placed the type in `utils.zig`).

```zig
var cfg: utils.ControlFlowGraph(ir.Instr) =
    try .init(gpa, func_def.instrs);
defer cfg.deinit(gpa);
```

Creating it in the function `optimize` seems to build fine, so I assume there no major fuck ups. I still need another function to extract the concatenated instruction list from it. So let's do that. This is the method on CFG:

```zig
pub fn concat(
    self: @This(),
    gpa: std.mem.Allocator,
    instrs: *std.ArrayListUnmanaged(Instr),
) !void {
    var out: std.ArrayListUnmanaged(Instr) = .empty;
    // swapping dance
    defer {
        std.mem.swap(
            std.ArrayListUnmanaged(Instr),
            &out,
            instrs,
        );
        out.deinit(gpa);
    }

    // actual work
    for (self.nodes.items) |node| if (node == .basic_block)
        try out.appendSlice(gpa, node.basic_block.items);
}
```

And this is used in `optimize` like this:

```zig
try cfg.concat(gpa, &func_def.instrs);
```

One thing left, I will not be _adding_ nodes, but I will definitely be editing them and deleting them. The editing part is simple enough, just pass a pointer around. The deleting part is tricky. Simply removing them from the `ArrayList` will be a terrible idea because it would mess up the indices (and therefore the edges) for the _other_ nodes. Instead, one should replace it with what's commonly called a tombstone: a sentinel value meaning this has been deleted. Cleaning up the edges is just a matter of deelting them.[^efficient] The tricky part is deleting from an `ArrayList` while iterating over it might invalidate the memory. Iterating _backwards_ solves this problem.

[^efficient]: A more efficient data structure would be probably more apt for a real compiler, but eh.

```zig
const Node = union(enum) {
    entry,
    exit,
    tombstone, // <-- add this
    basic_block: std.ArrayListUnmanaged(Instr),
};

pub fn delete_node(
    self: *@This(),
    gpa: std.mem.Allocator,
    index: usize,
) void {
    std.debug.assert(self.nodes.items[index] == .basic_block);

    // no leak memory!!
    self.nodes.items[index].basic_block.deinit(gpa);
    self.nodes.items[index] = .tombstone;

    var idx = self.edges.items.len;
    while (idx > 0) : (idx -= 1) {
        const edge = self.edges.items[idx - 1];

        // This changes the order of edges but no matter. Inefficient anyay
        if (edge.@"0" == index or edge.@"1" == index)
            _ = self.edges.swapRemove(idx - 1);
    }
}
```

I am still ignoring traversal for now. I will see how far I can go without implementing it directly.
