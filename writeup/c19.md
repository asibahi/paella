# Writing a C Compiler, Chapter 19, in Zig

<!-- Done Date: 2025-06-04 -->

Whoa whoa.. we were just in [chapter 10](c10.md) of [Writing a C Compiler](https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html): how did we jump to chapter 19 so fast? The answer is that I skipped these pesky chapters about implementing types in the middle, and jumped straight to Part 3, which is abput optimizations.

I have not actually read those chapters before, so now is the time! This chapter seems to be about machine-independent (read: IR) optimizations: constant folding and what have you.

---

## Compiler Driver

The first task in this chapter is to update the compiler driver, and what flags it can take. This a bit more complex than how I originally implemented it, because now multiple flags for different optimization passes can be combined. And it needs assembly in stdout. I might end up getting out of this project with my own argument parsing library. Anyway, this is the current implementation in full.

```zig
const Args = struct {
    path: [:0]const u8,
    mode: Mode,
    c_flag: bool,
};

const Mode = enum {
    lex,
    parse,
    validate,
    tacky,
    codegen,
    compile, // default
    assembly, // unused by test script - useful for debugging
};

fn parse_args() !Args {
    var args = std.process.args();
    _ = args.skip();

    var path: ?[:0]const u8 = null;
    var mode: Mode = .compile;
    var c_flag = false;

    while (args.next()) |arg| {
        if (arg[0] == '-') {
            if (arg[1] == 'c')
                c_flag = true
            else
                mode = std.meta.stringToEnum(Mode, arg[2..]) orelse
                    return error.UnrecognizedFlag;
        } else if (path == null)
            path = arg
        else
            return error.PathDuplicated;
    }

    return .{
        .path = path orelse return error.PathNotFound,
        .mode = mode,
        .c_flag = c_flag,
    };
}
```

The new options to add are as follows: `-S` to generate an assembly file but stop short of linking it and compiling it. The existing `assembly` options (which I used to view assembly output) merely prints to standard error. The other flags can be combined: `--fold-constants`, `--propagate-copies`, `--eliminate-unreachable-code` (a mouthful), `--eliminate-dead-stores`, and finally `--optimize` which enables all four options. These would be passed to the optimization state.

This calls for bitsets! Where is Odin when you need it? The Zig standard library thankfully has a nice that replicates Odin's really cool bitsets: `EnumSet`.[^rust] This would go with another enum of optimizations, that I decided to encode dashes and all to avoid any unwanted behaviour in `stringToEnum`. Better be literal! This is the new function with the changes highlighted.

[^rust]: Also there is a cool Rust library with that name that does the same thing with proc macro magic. It used to be in the standard library but was culled unfairly.

```zig
const Args = struct {
    path: [:0]const u8,
    mode: Mode,
    c_flag: bool,
    optimizations: std.EnumSet(Optimization), // new field!
};

const Mode = enum {
    lex,
    parse,
    validate,
    tacky,
    codegen,
    compile, // default
    assembly,
    output_assembly, // <-- -S : generate an assembly file
};

const Optimization = enum { // <-- new type. moves to ir_opt.zig
    @"fold-constants",
    @"propagate-copies",
    @"eliminate-unreachable-code",
    @"eliminate-dead-stores",
};

fn parse_args() !Args {
    var args = std.process.args();
    _ = args.skip();

    var path: ?[:0]const u8 = null;
    var mode: Mode = .compile;
    var c_flag = false;
    var optimizations: std.EnumSet(Optimization) = .initEmpty(); // <-- fill this

    while (args.next()) |arg| {
        if (arg[0] == '-') {
            if (arg[1] == 'c')
                c_flag = true
            else if (arg[1] == 'S' or arg[1] == 's') // <-- what if it is a typo?
                mode = .output_assembly
            else if (std.meta.stringToEnum(Mode, arg[2..])) |m|
                mode = m
            else if (std.meta.stringToEnum(Optimization, arg[2..])) |opt| // <--
                optimizations.insert(opt)
            else if (std.mem.eql(u8, "optimize", arg[2..])) // <-- with everything
                optimizations = .initFull()
            else
                return error.UnrecognizedFlag;
        } else if (path == null)
            path = arg
        else
            return error.PathDuplicated;
    }

    return .{
        .path = path orelse return error.PathNotFound,
        .mode = mode,
        .c_flag = c_flag,
        .optimizations = optimizations, // <--
    };
}
```

This then gets threaded into the `run` function as needed. I will not bore you with the details.

## The Optimizer

The Optimizer takes an `ir.FuncDef` and the `Optimization` `EnumSet` and keeps applying the provided optimizations until there are no more changes. Sounds interesting, but how do I make it so comparing old and new function definitions is as fast as possible? Do I just use `std.mem.eql`? This is the current definition of `ir.FuncDef`.

```zig
pub const FuncDef = struct {
    name: Identifier,
    global: bool = false, // assigned later than contruction
    params: std.ArrayListUnmanaged(Identifier),
    instrs: std.ArrayListUnmanaged(Instr),

    fn deinit(self: *@This(), alloc: std.mem.Allocator) void {
        for (self.instrs.items) |*i| i.deinit(alloc);
        self.params.deinit(alloc);
        self.instrs.deinit(alloc);
    }
};
```

I am more or less thinking aloud here, so bear with me. No point in comparing `name`, `global`, or `params`, as they will not be affected by the optimizations in the Book. Only `instrs`, which is, if you dig enough in the code, is a struct of a slice and capacoity. No point in comparing the capacity, so comparing the two slices of `Instr` should be enough. Comaprings the lengths of slices is pointedly _not_ enough because not all optimizations change the length.

But wait, I hear you say, could you not just return whether the optimization pass made a change at all? That actually sounds simpler, to be honest. I think I will go with that.

Adapting the Book's pseudocode to Zig gives the following. This is just a draft with stubs, mind you: a place to start with.

```zig
pub fn optimize(
    gpa: std.mem.Allocator,
    instrs: std.ArrayListUnmanaged(ir.Instr),
    opts: std.EnumSet(Optimization),
) std.ArrayListUnmanaged(ir.Instr) {
    if (instrs.items.len == 0) return instrs;

    var work = true;
    while (work) {
        work = false;

        const folded_instrs =
            if (opts.contains(.@"fold-constants")) lbl: {
                work = true; // obviously wrong. this is a draft
                break :lbl fold_constants(gpa, instrs);
            } else instrs;

        var cfg = make_control_flow_graph(gpa, folded_instrs);

        if (opts.contains(.@"eliminate-unreachable-code")) {
            work = true;
            cfg = eliminate_unreachable_code(gpa, cfg);
        }

        if (opts.contains(.@"propagate-copies")) {
            work = true;
            cfg = propagate_copies(gpa, cfg);
        }

        if (opts.contains(.@"eliminate-dead-stores")) {
            work = true;
            cfg = eliminate_dead_stores(gpa, cfg);
        }

        const ret_instrs = cfg_to_instrs(cfg);
        if (ret_instrs.items.len == 0 or !work) {
            return ret_instrs;
        }

        instrs = ret_instrs;
    }
}
```

Obviously setting `work` to `true` right there is wrong. This could be informed by the child funtions whether they made a change or not. But this is a draft, and I will figure out how this looks like later.

Of interest here is that only the first pass works on instrutions immediately, while the rest operate on a control flow graph.

## Constant Folding

With the stub filled up, time to flesh out the constant folding pass. This will work in a similar manner to how the instruction fixup pass works: a new empty `ArrayList` will be created, and filled up with instructions one by one, then the old `ArrayList` is a deallocated and the new one is returned in its stead.

Copying the signature and the main structure of that function gives me the following stub. It is already different to my assumptions in the previous listing, but that is ok.

```zig
fn fold_constants(
    gpa: std.mem.Allocator,
    func_def: *ir.FuncDef,
) !bool {
    var out: std.ArrayListUnmanaged(ir.Instr) = try .initCapacity(
        gpa,
        func_def.instrs.capacity,
    );
    defer {
        std.mem.swap(
            std.ArrayListUnmanaged(ir.Instr),
            &out,
            &func_def.instrs,
        );
        out.deinit(gpa);
    }

    var work = false;

    for (func_def.instrs.items) |instr| {
        // todo
    }

    return work;
}
```

The pass would evaluate all binary and unary instructions, and the two conditional jumps. For example, this is how it would work for `binop_add` and `jump_z`.

```zig
switch (instr) {
    .binop_add => |b| if (b.src1 == .constant and b.src2 == .constant) {
        work = true;
        const res: ir.Value =
            .{ .constant = b.src1.constant +% b.src2.constant };
        try out.append(gpa, .{ .copy = .init(res, b.dst) });
    } else try out.append(gpa, instr),

    .jump_z => |j| if (j.cond == .constant) {
        work = true;
        if (j.cond.constant == 0)
            try out.append(gpa, .{ .jump = j.target });
    } else try out.append(gpa, instr),

    // the rest of the instructions
}
```

This looks simple enough, if it is a bit of a slog.[^llm] I will spare writing every line of this large switch. There is nothing particularly illuminating. The use of the `+%` operator is to fend against integer overflow, which is undefined behavious in C. Here I am choosing to simply wrap it like a sane person would.

[^llm]: I am sure I can get an Agent to spare me the misery but the misery is the point.

This is it for constant folding apparently. There is other stuff to do if I had gone through Part 2 and added other types, but I have not, so there is not. Doing the wiring is fairly tedious work that I am not going to write here. The draft optimization loop above has changed to this:

```zig
pub fn optimize(
    gpa: std.mem.Allocator,
    func_def: *ir.FuncDef,
    opts: std.EnumSet(Optimization),
) !void {
    if (func_def.instrs.items.len == 0) return;

    while (true) {
        var work_done = false;

        if (opts.contains(.@"fold-constants"))
            work_done = try fold_constants(gpa, func_def) or work_done;

        // var cfg = make_control_flow_graph(gpa, func_def.instrs);

        // if (opts.contains(.@"eliminate-unreachable-code")) {
        //     work_done = true;
        //     cfg = eliminate_unreachable_code(gpa, cfg);
        // }

        // if (opts.contains(.@"propagate-copies")) {
        //     work_done = true;
        //     cfg = propagate_copies(gpa, cfg);
        // }

        // if (opts.contains(.@"eliminate-dead-stores")) {
        //     work_done = true;
        //     cfg = eliminate_dead_stores(gpa, cfg);
        // }

        // const ret_instrs = cfg_to_instrs(cfg);

        if (func_def.instrs.items.len == 0 or !work_done)
            return;

        // instrs = ret_instrs;
    }
}
```

One annoyance I had to deal with: in other to make sure the correct addition and negation semantics, I had to change the type I am using to store integers throughout the codebase from a `u64` (which is generically useful) to `i32`. Zig makes dealing with numerical code very onerous. Also did you know you cannot use the `/` and `%` operators for signed integers? I did not, but the compiler told me!

Running the tests has them all pass. Excellent. I am unsure what wizardry the tests do to ascertain that I have constant folded correctly, but if they tell me I am good then I am good.[^readme] Moving on.

[^readme]: Oh there is a `README` that explains it. It works by checking for _any_ binary operations in certain functions. Clever, to be honest.

## Control Flow Graphs
