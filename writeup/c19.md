# Writing a C Compiler, Chapter 19, in Zig

<!-- Done Date: 2025-06-04 -->

Whoa whoa.. we were just in [chapter 10](c10.md) of [Writing a C Compiler](https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html): how did we jump to chapter 19 so fast? The answer is that I skipped these pesky chapters about implementing types in the middle, and jumped straight to Part 3, which is abput optimizations.

I have not actually read those chapters before, so now is the time! This chapter seems to be about machine-independent (read: IR) optimizations: constant folding and what have you.

---

## Compiler Driver

The first task in this chapter is to update the compiler driver, and what flags it can take. This a bit more complex than how I originally implemented it, because now multiple flags for different optimization passes can be combined. And it needs assembly in stdout. I might end up getting out of this project with my own argument parsing library. Anyway, this is the current implementation in full.

```zig
pub const Args = struct {
    path: [:0]const u8,
    mode: Mode,
    c_flag: bool,
};

pub const Mode = enum {
    lex,
    parse,
    validate,
    tacky,
    codegen,
    compile, // default
    assembly, // unused by test script - useful for debugging
};

pub fn parse_args() !Args {
    var args = std.process.args();
    _ = args.skip();

    var path: ?[:0]const u8 = null;
    var mode: Mode = .compile;
    var c_flag = false;

    while (args.next()) |arg| {
        if (arg[0] == '-') {
            if (arg[1] == 'c')
                c_flag = true
            else
                mode = std.meta.stringToEnum(Mode, arg[2..]) orelse
                    return error.UnrecognizedFlag;
        } else if (path == null)
            path = arg
        else
            return error.PathDuplicated;
    }

    return .{
        .path = path orelse return error.PathNotFound,
        .mode = mode,
        .c_flag = c_flag,
    };
}
```

The new options to add are as follows: `-S` to generate an assembly file but stop short of linking it and compiling it. The existing `assembly` options (which I used to view assembly output) merely prints to standard error. The other flags can be combined: `--fold-constants`, `--propagate-copies`, `--eliminate-unreachable-code` (a mouthful), `--eliminate-dead-stores`, and finally `--optimize` which enables all four options. These would be passed to the optimization state.

This calls for bitsets! Where is Odin when you need it? The Zig standard library thankfully has a nice that replicates Odin's really cool bitsets: `EnumSet`.[^rust] This would go with another enum of optimizations, that I decided to encode dashes and all to avoid any unwanted behaviour in `stringToEnum`. Better be literal! This is the new function with the changes highlighted.

[^rust]: Also there is a cool Rust library with that name that does the same thing with proc macro magic. It used to be in the standard library but was culled unfairly.

```zig
pub const Args = struct {
    path: [:0]const u8,
    mode: Mode,
    c_flag: bool,
    optimizations: std.EnumSet(Optimization), // new field!
};

pub const Mode = enum {
    lex,
    parse,
    validate,
    tacky,
    codegen,
    compile, // default
    assembly,
    output_assembly, // <-- -S : generate an assembly file
};

pub const Optimization = enum {
    @"fold-contants",
    @"propagate-copies",
    @"eliminate-unreachable-code",
    @"eliminate-dead-stores",
};

pub fn parse_args() !Args {
    var args = std.process.args();
    _ = args.skip();

    var path: ?[:0]const u8 = null;
    var mode: Mode = .compile;
    var c_flag = false;
    var optimizations: std.EnumSet(Optimization) = .initEmpty(); // <-- fill this

    while (args.next()) |arg| {
        if (arg[0] == '-') {
            if (arg[1] == 'c')
                c_flag = true
            else if (arg[1] == 'S' or arg[1] == 's') // <-- what if it is a typo?
                mode = .output_assembly
            else if (std.meta.stringToEnum(Mode, arg[2..])) |m|
                mode = m
            else if (std.meta.stringToEnum(Optimization, arg[2..])) |opt| // <--
                optimizations.insert(opt)
            else if (std.mem.eql(u8, "optimize", arg[2..])) // <-- with everything
                optimizations = .initFull()
            else
                return error.UnrecognizedFlag;
        } else if (path == null)
            path = arg
        else
            return error.PathDuplicated;
    }

    return .{
        .path = path orelse return error.PathNotFound,
        .mode = mode,
        .c_flag = c_flag,
        .optimizations = optimizations, // <--
    };
}
```

This then gets threaded into the `run` function as needed. I will not bore you with the details.
