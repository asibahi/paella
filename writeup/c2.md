# Writing a C Compiler - Chapter 2 - in Zig

So, with the [first chapter](c1.md) of [Writing a C Compiler](https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html) behind us, it is time to start on the swcond chapter: Unary Operators. But first, a word from `build.zig` land.

## Running the tests with `zig build test`

The tests for ths Book live in [their own repositry](https://github.com/nlsandler/writing-a-c-compiler-tests), which I have dutifully cloned and run tests in.

The process I followed to run the tests is fairly manual:

1. navigate to the test directory.
2. run the command `arch -x86_64 zsh` (which I have cleverly aliased to `x86`). This runs a x86 version of `zsh`.
3. run the tests.

When I was doing [my Rust implementation](https://github.com/asibahi/trjm), I kept a terminal accessible with a global hotkey and I kept the inner shell running at all times.

With `build.zig`, I looked for a way to do that automatically. The `Build` object, which is central to `build.zig` has a nice `addSystemCommand` method, which I could use to run my stuff in. Now remained the problem of how to run the tests in the x86 shell.

My first thought was to have the command as `arch -x86_64 test_compiler ..etc` (`test_compiler` being the test script provided). While it worked, as in the tests for chapter 1 all ran fine, upon further reading I realized that the `arch` actually chooses which binary to run from a macOS Universal Binary. It has no effect on python scripts, and the simple tests on chapter 1 worked fine either way. So I asked around, and some kind soul pointed me to the right thing to search for: Subshells.

See, this might seem obvious if you've lived in Unix land all your life, but shells are applications too. You can pass command line arguments to them!! So, `bash -c "echo foo"`, runs `bash`, runs the command `echo foo` in `bash`, then exits. Pefect.

Putting these two together, this was the added bit to `build.zig`:

```zig
const test_step = b.step("test", "Run tests");

// subshells. how do they work.
const inner_command = try std.mem.join(b.allocator, " ", &.{
    "../writing-a-c-compiler-tests/test_compiler",
    b.pathJoin(&.{ b.exe_dir, "paella" }),
    try std.mem.join(
        b.allocator,
        " ",
        b.args orelse &.{""},
    ),
});

// does this work like i think it does?
const test_command = b.addSystemCommand(
    &.{ "arch", "-x86_64", "zsh", "-c", inner_command },
);

test_command.step.dependOn(b.getInstallStep());
test_step.dependOn(&test_command.step);
```

I am unreasonably happy with this. Using regular Zig standard library tools like `std.mem.join` allowed to join together the commands I am passing to the `zsh` subshell, and voila!!

Now the tests (say for chapter 1) can be ran "simply" with `zig build test -- --chapter 1`. Great success!

## Lexer

There are three tokens to add in this chapter: `~`, `-`, and `--`. The decrement operator is only being tokenized here to reject illegal C syntax like `return --2`, but otherwise will not be implemented.

[^main]: I refactored the code a bit after chapter 1 and added proper support for the `idenitfier` token. It is a trivial change so no point in detailing it further, except that the new `expect` is cooler than before.

So our `Tag` enum grows[^main] to have these three tokens: `tilde, hyphen`. As I am not planning to implement the book's extra credit this time around, I will just have the double hyphen lex into the `invalid` token. This would reject lexing valid code like `x--`, but I do not think this is going to be present into the test cases. We will see.

The `State` enum is a bit more interesting. It cannot accept two consecutive hyphens, so seeing a hyphen would put it into the `hyphen` state, where if it sees another hyphen, it puts out `Tag.invalid`, or `Tag.hyphen` otherwise.

So, if the state is at `.start`, and the lexer encounters a `'-'` character, it just switches gear to the `.hyphen` state. Labelled `switch` in action. Then in there, triage happens. The code is honestly copied, again, from the Zig compiler, with adjustments.

```zig
state: switch (State.start) {
    .start => switch (self.buffer[self.index]) {
        '~' => {
            result.tag = .tilde;
            self.index += 1;
        },
        '-' => continue :state .hyphen,
        // etc
    .hyphen => {
        self.index += 1;
        switch (self.buffer[self.index]) {
            '-' => result.tag = .invalid,
            else => result.tag = .hyphen,
        }
    },
    // etc
}
```

This should be it. Time to put the new testing command into action.

```
Ran 43 tests in 5.432s

OK
```

Both of them work. Time for AST and parsing.

## Parsing

Changes to the AST are fairly minimal. There are two unary operations: negation, and complement. Instead of adding a spearate `UnaryOp` enum as the Book suggests, I am going to embed them right into `Expr` as spearate tags, updating the pretty printer while I am at it.[^json]

[^json]: There is an argument to be made for replacing my custom pretty printer with standard library's `json` serilaizr. The result is more verbose and has more vertical space and redundant info, but on the plus side, it requires zero maintenance.

```zig
pub const Expr = union(enum) {
    constant: u64,
    unop_negate: *Expr,
    unop_complement: *Expr,

    pub fn format(
        self: @This(),
        comptime _: []const u8,
        _: std.fmt.FormatOptions,
        writer: anytype,
    ) !void {
        switch (self) {
            .constant => |c| try writer.print("{d}", .{c}),
            .unop_negate => |e| try writer.print(" -{}", .{e}),
            .unop_complement => |e| try writer.print(" ~{}", .{e}),
        }
    }
};
```

Updating the parsing functions is a bit more involved, however. Now is the start of PEMDAS, and time to start our recursive descemt into madness.[^madness] This is pretty much the same function provided in the book, except that the operation is chosen immediately.

[^madness]: Sounds good for a book title or something, doesn't it?

```zig
fn parse_expr(
    alloc: std.mem.Allocator,
    tokens: *lexer.Tokenizer,
) !*ast.Expr {
    const current = tokens.next() orelse
        return error.ExpectExpr;

    switch (current.tag) {
        .number_literal => {
            const lit = tokens.buffer[current.loc.start..current.loc.end];
            const res = try std.fmt.parseInt(u64, lit, 10);

            //         vvv this helper function just allocates and sets
            return try create(ast.Expr, alloc, .{ .constant = res });
        },
        .hyphen => {
            const inner_exp = try parse_expr(alloc, tokens);
            return try create(ast.Expr, alloc, .{ .unop_negate = inner_exp });
        },
        .tilde => {
            const inner_exp = try parse_expr(alloc, tokens);
            return try create(ast.Expr, alloc, .{ .unop_complement = inner_exp });
        },
        .l_paren => {
            const inner_exp = try parse_expr(alloc, tokens);
            try expect(.r_paren, tokens);

            return inner_exp;
        },
        else => return error.ExpectExpr,
    }
}
```

Now the parsing is done, but to test a small annoyance needs to be fixed. In `asm_gen.zig`, there is a switch over expressions, and it needs to handle the new modes, eben tho it is not being called right now. This tedium and the need to repeat it for every step is partially why I stopped the Rust implementation. Adding a `else => @panic("unimplemented"),` to that `switch` smoothes things over for now.

```
Ran 43 tests in 6.363s

OK
```

Yuppee.

Last but not least, even though it is not needed for the first chapters, as the only idenitfier is `main`, I figured I'd try some `comptime` magic to improve my expectation experiance. I changed `expect` a little bit so it returns a string when I am asking for an identifier, but `void` otherwise.[^matklad]

```zig
fn expect(
    comptime expected: lexer.Token.Tag,
    tokens: *lexer.Tokenizer,
) !if (expected == .identifier)
    []const u8
else
    void {
    if (tokens.next()) |actual| {
        if (actual.tag != expected)
            return error.SyntaxError;
        if (expected == .identifier)
            return tokens.buffer[actual.loc.start..actual.loc.end];
    } else return error.SyntaxError;
}
```

[^matklad]: Inspired by [matklad](https://matklad.github.io/2025/04/21/fun-zig-program.html).
