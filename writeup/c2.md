# Writing a C Compiler - Chapter 2 - in Zig

So, with the [first chapter](c1.md) of [Writing a C Compiler](https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html) behind us, it is time to start on the swcond chapter: Unary Operators. But first, a word from `build.zig` land.

## Running the tests with `zig build test`

The tests for ths Book live in [their own repositry](https://github.com/nlsandler/writing-a-c-compiler-tests), which I have dutifully cloned and run tests in.

The process I followed to run the tests is fairly manual:
1. navigate to the test directory.
2. run the command `arch -x86_64 zsh` (which I have cleverly aliased to `x86`). This runs a x86 version of `zsh`.
3. run the tests.

When I was doing [my Rust implementation](https://github.com/asibahi/trjm), I kept a terminal accessible with a global hotkey and I kept the inner shell running at all times.

With `build.zig`, I looked for a way to do that automatically. The `Build` object, which is central to `build.zig` has a nice `addSystemCommand` method, which I could use to run my stuff in. Now remained the problem of how to run the tests in the x86 shell.

My first thought was to have the command as `arch -x86_64 test_compiler ..etc` (`test_compiler` being the test script provided). While it worked, as in the tests for chapter 1 all ran fine, upon further reading I realized that the `arch` actually chooses which binary to run from a macOS Universal Binary. It has no effect on python scripts, and the simple tests on chapter 1 worked fine either way. So I asked around, and some kind soul pointed me to the right thing to search for: Subshells.

See, this might seem obvious if you've lived in Unix land all your life, but shells are applications too. You can pass command line arguments to them!! So, `bash -c "echo foo"`, runs `bash`, runs the command `echo foo` in `bash`, then exits. Pefect.

Putting these two together, this was the added bit to `build.zig`:

```zig
const test_step = b.step("test", "Run tests");

// subshells. how do they work.
const inner_command = try std.mem.join(b.allocator, " ", &.{
    "../writing-a-c-compiler-tests/test_compiler",
    b.pathJoin(&.{ b.exe_dir, "paella" }),
    try std.mem.join(
        b.allocator,
        " ",
        b.args orelse &.{""},
    ),
});

// does this work like i think it does?
const test_command = b.addSystemCommand(
    &.{ "arch", "-x86_64", "zsh", "-c", inner_command },
);

test_command.step.dependOn(b.getInstallStep());
test_step.dependOn(&test_command.step);
```

I am unreasonably happy with this. Using regular Zig standard library tools like `std.mem.join` allowed to join together the commands I am passing to the `zsh` subshell, and voila!!

Now the tests (say for chapter 1) can be ran "simply" with `zig build test -- --chapter 1`. Great success!

## Lexer

There are three tokens to add in this chapter: `~`, `-`, and `--`. The decrement operator is only being tokenized here to reject illegal C syntax like `return --2`, but otherwise will not be implemented.

[^main]: I refactored the code a bit after chapter 1 and added proper support for the `idenitfier` token, and added a new `expect_ident` parsing function. It is a trivial change so no point in detailing it further.

So our `Tag` enum grows[^main] to have these three tokens: `tilde, hyphen`. As I am not planning to implement the book's extra credit this time around, I will just have the double hyphen lex into the `invalid` token. This would reject lexing valid code like `x--`, but I do not think this is going to be present into the test cases. We will see.

The `State` enum is a bit more interesting. It cannot accept two consecutive hyphens, so seeing a hyphen would put it into the `hyphen` state, where if it sees another hyphen, it puts out `Tag.invalid`, or `Tag.hyphen` otherwise.

So, if the state is at `.start`, and the lexer encounters a `'-'` character, it just switches gear to the `.hyphen` state. Labelled `switch` in action. Then in there, triage happens. The code is honestly copied, again, from the Zig compiler, with adjustments.

```zig
state: switch (State.start) {
    .start => switch (self.buffer[self.index]) {
        '~' => {
            result.tag = .tilde;
            self.index += 1;
        },
        '-' => continue :state .hyphen,
        // etc
    .hyphen => {
        self.index += 1;
        switch (self.buffer[self.index]) {
            '-' => result.tag = .invalid,
            else => result.tag = .hyphen,
        }
    },
    // etc
}
```

This should be it. Time to put the new testing command into action.

```
----------------------------------------------------------------------
Ran 43 tests in 5.432s

OK
```

Both of them work. Time for Parsing.
